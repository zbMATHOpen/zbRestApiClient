# coding: utf-8

"""
    REST API for zbMATH Open

    a REST api for zbMATH Open, currently with endpoints for authors, classifications, documents, serials and software  # noqa: E501

    OpenAPI spec version: v0.4.3rc0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DocumentApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_document_by_field_document_structured_search_get(self, **kwargs):  # noqa: E501
        """search documents by descriptive field names  # noqa: E501

                 # Description                    For searching in zbMATH you may employ the Structured Search for         convenient combination of all search fields. While similar to the         1-line syntax search, this endpoint offers much more convenience and         transparency which fields are searched at the cost of search         flexibility.                    # Examples           - **field:** 'contributor_name', **term:** 'smith': Search for         author, author reference or editor named **Smith**           - **field:** 'year', **term:** '2002-2005': Search for documents         published in the years from **2002* until **2005**           - **field:** 'reference_author_code', **term:** 'smith.ivan':         Search for documents with references that were written by the author         with the zbMATH code **smith.ivan**           - **field:** 'reference_zbmath_id', **term:** '6383667': Search for         documents that reference to a document with the zbMATH id **6383667**           - **field:** 'zbmath_id', **term:** '6383667': Search for the         document with the zbMATH id **6383667**. zbMATH id includes all types         of identifiers used on zbmath.org, i.e.: pre ID, Zbl ID, JFM ID,         ERAM ID          # Search fields  - **author_code**: zbMATH author code - **author_count**: number of authors of the document in question - **author_reference_code**: zbMATH code of an author reference - **biographic_reference_code**: zbMATH code of the biographic reference - **biographic_reference_name**: name of the biographic reference - **citing**: cited documents - **contributor_code**: zbMATH code of any contributor of a document - **contributor_name**: name of any contributor of a document - **database**: database name - **document_type**: type of a document - **editor_code**: zbMATH code of editor - **editor_name**: name of editor - **external_id / type**: external identifier or type - **issue_id**: zbMATH id of the corresponding issue - **keyword**: keyword of the document - **language**: language - **msc_code**: msc code (any level) - **msc_title**: title of msc code - **publisher**: publisher - **reference_author_code**: zbMATH code of author in reference - **reference_msc**: msc code of reference - **reference_series_id**: zbMATH id of serial - **reference_text**: reference text - **reference_year**: publishing year of reference - **reference_zbmath_id**: zbMATH id of reference - **related url**: related url - **review_text**: review text - **reviewer_code**: zbMATH code of reviewer - **reviewer_name**: name of reviewer - **reviewing_state**: reviewing state - **series_id**: zbMATH id of serial - **software_id**: zbMATH id of related software - **software_name**: name of related software - **source**: name of source - **state**: state of publication - **title**: title - **unique_author_code**: zbMATH code of a uniquely identified author of a document - **unique_contributor_code**: zbMATH code of a uniquely identified contributor of a document - **unique_editor_code**: zbMATH code of a uniquely identified editor of a document - **year**: year of publishing (range of year possible: XXXX-YYYY) - **zbmath_id**: zbMATH id of document. This includes all types of identifiers used on zbmath.org, i.e.: pre ID, Zbl ID, JFM ID, ERAM ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_by_field_document_structured_search_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: pagination for result page
        :param int results_per_page:
        :param str review_text: review_text
        :param str unique_contributor_code: unique_contributor_code
        :param str contributor_code: contributor_code
        :param str zbmath_id: zbmath_id
        :param str author_reference_code: author_reference_code
        :param str contributor_name: contributor_name
        :param str biographic_reference_code: biographic_reference_code
        :param str biographic_reference_name: biographic_reference_name
        :param str unique_author_code: unique_author_code
        :param str msc_title: msc_title
        :param str msc_code: msc_code
        :param str citing: citing
        :param str database: database
        :param str document_type: document_type
        :param str unique_editor_code: unique_editor_code
        :param str editor_name: editor_name
        :param str editor_code: editor_code
        :param str external_id__type: external_id / type
        :param str author_code: author_code
        :param str issue_id: issue_id
        :param str language: language
        :param str related_url: related url
        :param str author_count: author_count
        :param str reviewing_state: reviewing_state
        :param str publisher: publisher
        :param str year: year
        :param str reference_author_code: reference_author_code
        :param str reference_msc: reference_msc
        :param str reference_zbmath_id: reference_zbmath_id
        :param str reference_text: reference_text
        :param str reference_series_id: reference_series_id
        :param str reviewer_code: reviewer_code
        :param str reviewer_name: reviewer_name
        :param str reference_year: reference_year
        :param str series_id: series_id
        :param str software_id: software_id
        :param str source: source
        :param str state: state
        :param str software_name: software_name
        :param str title: title
        :param str keyword: keyword
        :return: ZbmathApiDataModelsDisplayDocumentsResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_document_by_field_document_structured_search_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_document_by_field_document_structured_search_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_document_by_field_document_structured_search_get_with_http_info(self, **kwargs):  # noqa: E501
        """search documents by descriptive field names  # noqa: E501

                 # Description                    For searching in zbMATH you may employ the Structured Search for         convenient combination of all search fields. While similar to the         1-line syntax search, this endpoint offers much more convenience and         transparency which fields are searched at the cost of search         flexibility.                    # Examples           - **field:** 'contributor_name', **term:** 'smith': Search for         author, author reference or editor named **Smith**           - **field:** 'year', **term:** '2002-2005': Search for documents         published in the years from **2002* until **2005**           - **field:** 'reference_author_code', **term:** 'smith.ivan':         Search for documents with references that were written by the author         with the zbMATH code **smith.ivan**           - **field:** 'reference_zbmath_id', **term:** '6383667': Search for         documents that reference to a document with the zbMATH id **6383667**           - **field:** 'zbmath_id', **term:** '6383667': Search for the         document with the zbMATH id **6383667**. zbMATH id includes all types         of identifiers used on zbmath.org, i.e.: pre ID, Zbl ID, JFM ID,         ERAM ID          # Search fields  - **author_code**: zbMATH author code - **author_count**: number of authors of the document in question - **author_reference_code**: zbMATH code of an author reference - **biographic_reference_code**: zbMATH code of the biographic reference - **biographic_reference_name**: name of the biographic reference - **citing**: cited documents - **contributor_code**: zbMATH code of any contributor of a document - **contributor_name**: name of any contributor of a document - **database**: database name - **document_type**: type of a document - **editor_code**: zbMATH code of editor - **editor_name**: name of editor - **external_id / type**: external identifier or type - **issue_id**: zbMATH id of the corresponding issue - **keyword**: keyword of the document - **language**: language - **msc_code**: msc code (any level) - **msc_title**: title of msc code - **publisher**: publisher - **reference_author_code**: zbMATH code of author in reference - **reference_msc**: msc code of reference - **reference_series_id**: zbMATH id of serial - **reference_text**: reference text - **reference_year**: publishing year of reference - **reference_zbmath_id**: zbMATH id of reference - **related url**: related url - **review_text**: review text - **reviewer_code**: zbMATH code of reviewer - **reviewer_name**: name of reviewer - **reviewing_state**: reviewing state - **series_id**: zbMATH id of serial - **software_id**: zbMATH id of related software - **software_name**: name of related software - **source**: name of source - **state**: state of publication - **title**: title - **unique_author_code**: zbMATH code of a uniquely identified author of a document - **unique_contributor_code**: zbMATH code of a uniquely identified contributor of a document - **unique_editor_code**: zbMATH code of a uniquely identified editor of a document - **year**: year of publishing (range of year possible: XXXX-YYYY) - **zbmath_id**: zbMATH id of document. This includes all types of identifiers used on zbmath.org, i.e.: pre ID, Zbl ID, JFM ID, ERAM ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_by_field_document_structured_search_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: pagination for result page
        :param int results_per_page:
        :param str review_text: review_text
        :param str unique_contributor_code: unique_contributor_code
        :param str contributor_code: contributor_code
        :param str zbmath_id: zbmath_id
        :param str author_reference_code: author_reference_code
        :param str contributor_name: contributor_name
        :param str biographic_reference_code: biographic_reference_code
        :param str biographic_reference_name: biographic_reference_name
        :param str unique_author_code: unique_author_code
        :param str msc_title: msc_title
        :param str msc_code: msc_code
        :param str citing: citing
        :param str database: database
        :param str document_type: document_type
        :param str unique_editor_code: unique_editor_code
        :param str editor_name: editor_name
        :param str editor_code: editor_code
        :param str external_id__type: external_id / type
        :param str author_code: author_code
        :param str issue_id: issue_id
        :param str language: language
        :param str related_url: related url
        :param str author_count: author_count
        :param str reviewing_state: reviewing_state
        :param str publisher: publisher
        :param str year: year
        :param str reference_author_code: reference_author_code
        :param str reference_msc: reference_msc
        :param str reference_zbmath_id: reference_zbmath_id
        :param str reference_text: reference_text
        :param str reference_series_id: reference_series_id
        :param str reviewer_code: reviewer_code
        :param str reviewer_name: reviewer_name
        :param str reference_year: reference_year
        :param str series_id: series_id
        :param str software_id: software_id
        :param str source: source
        :param str state: state
        :param str software_name: software_name
        :param str title: title
        :param str keyword: keyword
        :return: ZbmathApiDataModelsDisplayDocumentsResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'results_per_page', 'review_text', 'unique_contributor_code', 'contributor_code', 'zbmath_id', 'author_reference_code', 'contributor_name', 'biographic_reference_code', 'biographic_reference_name', 'unique_author_code', 'msc_title', 'msc_code', 'citing', 'database', 'document_type', 'unique_editor_code', 'editor_name', 'editor_code', 'external_id__type', 'author_code', 'issue_id', 'language', 'related_url', 'author_count', 'reviewing_state', 'publisher', 'year', 'reference_author_code', 'reference_msc', 'reference_zbmath_id', 'reference_text', 'reference_series_id', 'reviewer_code', 'reviewer_name', 'reference_year', 'series_id', 'software_id', 'source', 'state', 'software_name', 'title', 'keyword']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_by_field_document_structured_search_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'results_per_page' in params:
            query_params.append(('results_per_page', params['results_per_page']))  # noqa: E501
        if 'review_text' in params:
            query_params.append(('review_text', params['review_text']))  # noqa: E501
        if 'unique_contributor_code' in params:
            query_params.append(('unique_contributor_code', params['unique_contributor_code']))  # noqa: E501
        if 'contributor_code' in params:
            query_params.append(('contributor_code', params['contributor_code']))  # noqa: E501
        if 'zbmath_id' in params:
            query_params.append(('zbmath_id', params['zbmath_id']))  # noqa: E501
        if 'author_reference_code' in params:
            query_params.append(('author_reference_code', params['author_reference_code']))  # noqa: E501
        if 'contributor_name' in params:
            query_params.append(('contributor_name', params['contributor_name']))  # noqa: E501
        if 'biographic_reference_code' in params:
            query_params.append(('biographic_reference_code', params['biographic_reference_code']))  # noqa: E501
        if 'biographic_reference_name' in params:
            query_params.append(('biographic_reference_name', params['biographic_reference_name']))  # noqa: E501
        if 'unique_author_code' in params:
            query_params.append(('unique_author_code', params['unique_author_code']))  # noqa: E501
        if 'msc_title' in params:
            query_params.append(('msc_title', params['msc_title']))  # noqa: E501
        if 'msc_code' in params:
            query_params.append(('msc_code', params['msc_code']))  # noqa: E501
        if 'citing' in params:
            query_params.append(('citing', params['citing']))  # noqa: E501
        if 'database' in params:
            query_params.append(('database', params['database']))  # noqa: E501
        if 'document_type' in params:
            query_params.append(('document_type', params['document_type']))  # noqa: E501
        if 'unique_editor_code' in params:
            query_params.append(('unique_editor_code', params['unique_editor_code']))  # noqa: E501
        if 'editor_name' in params:
            query_params.append(('editor_name', params['editor_name']))  # noqa: E501
        if 'editor_code' in params:
            query_params.append(('editor_code', params['editor_code']))  # noqa: E501
        if 'external_id__type' in params:
            query_params.append(('external_id / type', params['external_id__type']))  # noqa: E501
        if 'author_code' in params:
            query_params.append(('author_code', params['author_code']))  # noqa: E501
        if 'issue_id' in params:
            query_params.append(('issue_id', params['issue_id']))  # noqa: E501
        if 'language' in params:
            query_params.append(('language', params['language']))  # noqa: E501
        if 'related_url' in params:
            query_params.append(('related url', params['related_url']))  # noqa: E501
        if 'author_count' in params:
            query_params.append(('author_count', params['author_count']))  # noqa: E501
        if 'reviewing_state' in params:
            query_params.append(('reviewing_state', params['reviewing_state']))  # noqa: E501
        if 'publisher' in params:
            query_params.append(('publisher', params['publisher']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'reference_author_code' in params:
            query_params.append(('reference_author_code', params['reference_author_code']))  # noqa: E501
        if 'reference_msc' in params:
            query_params.append(('reference_msc', params['reference_msc']))  # noqa: E501
        if 'reference_zbmath_id' in params:
            query_params.append(('reference_zbmath_id', params['reference_zbmath_id']))  # noqa: E501
        if 'reference_text' in params:
            query_params.append(('reference_text', params['reference_text']))  # noqa: E501
        if 'reference_series_id' in params:
            query_params.append(('reference_series_id', params['reference_series_id']))  # noqa: E501
        if 'reviewer_code' in params:
            query_params.append(('reviewer_code', params['reviewer_code']))  # noqa: E501
        if 'reviewer_name' in params:
            query_params.append(('reviewer_name', params['reviewer_name']))  # noqa: E501
        if 'reference_year' in params:
            query_params.append(('reference_year', params['reference_year']))  # noqa: E501
        if 'series_id' in params:
            query_params.append(('series_id', params['series_id']))  # noqa: E501
        if 'software_id' in params:
            query_params.append(('software_id', params['software_id']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'software_name' in params:
            query_params.append(('software_name', params['software_name']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/_structured_search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZbmathApiDataModelsDisplayDocumentsResultSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document_by_syntax_string_document_search_get(self, search_string, **kwargs):  # noqa: E501
        """search documents by zbMATH style user query  # noqa: E501

                 # Description                    The syntax search allows for free logical combinations of all         available search fields. While similar to the structured search,         this endpoint offers much more flexibility at the cost of obscure         search parameters.                    # Examples           - **Geometry**: Search for the term Geometry in any field. Queries are         case-independent.           - **Funct***: Wildcard queries are specified by * (e.g. functions,         functorial, etc.). Otherwise the search is exact.           - **\"Topological group\"**: Phrases (multi-words) should be set in         \"straight quotation marks\".           - **au: Bourbaki & ti: Algebra**: Search for author and title. The         and-operator & is default and can be omitted.           - **Chebyshev | Tschebyscheff**: The or-operator | allows to         search for Chebyshev or Tschebyscheff.           - **Quasi\\* map\\* py: 1989**: The resulting documents have         publication         year 1989.           - **so: Eur\\* J\\* Mat\\* Soc\\* cc: 14**: Search for publications in a         particular source with a Mathematics Subject Classification code (cc)         in 14.           - **\"Partial diff\\* eq\\*\" ! elliptic**: The not-operator ! eliminates         all results containing the word elliptic.           - **dt: b & au: Hilbert**: The document type is set to books;         alternatively: j for journal articles, a for book articles.           - **py: 2000-2015 cc: (94A | 11T)**: Number ranges are accepted.         Terms can be grouped within (parentheses).           - **la: chinese**: Find documents in a given language. ISO 639-1         (opens in new tab) language codes can also be used.          # Search fields  - **ab**: review text - **ac**: zbMATH code of a uniquely identified contributor of a document - **ai**: zbMATH code of any contributor of a document - **an**: zbMATH id of document. This includes all types of identifiers used on zbmath.org, i.e.: pre ID, Zbl ID, JFM ID, ERAM ID - **ar**: zbMATH code of an author reference - **au**: name of any contributor of a document - **bi**: zbMATH code of the biographic reference - **br**: name of the biographic reference - **ca**: zbMATH code of a uniquely identified author of a document - **cc**: title of msc code - **cca**: msc code (any level) - **ci**: cited documents - **db**: database name - **dt**: type of a document - **ec**: zbMATH code of a uniquely identified editor of a document - **ed**: name of editor - **ei**: zbMATH code of editor - **en**: external identifier or type - **ia**: zbMATH author code - **in**: zbMATH id of the corresponding issue - **la**: language - **li**: related url - **na**: number of authors of the document in question - **pt**: reviewing state - **pu**: publisher - **py**: year of publishing (range of year possible: XXXX-YYYY) - **ra**: zbMATH code of author in reference - **rc**: msc code of reference - **rf**: zbMATH id of reference - **rft**: reference text - **rj**: zbMATH id of serial - **rn**: zbMATH code of reviewer - **rv**: name of reviewer - **ry**: publishing year of reference - **se**: zbMATH id of serial - **si**: zbMATH id of related software - **so**: name of source - **st**: state of publication - **sw**: name of related software - **ti**: title - **ut**: keyword of the document            # Operators          - **a & b**: logical and          - **a | b**: logical or          - **!ab**: logical not          - **abc***: right wildcard          - **\"ab c\"**: phrase          - **(ab c)**: parentheses           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_by_syntax_string_document_search_get(search_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_string: (required)
        :param int page:
        :param int results_per_page:
        :return: ZbmathApiDataModelsDisplayDocumentsResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_document_by_syntax_string_document_search_get_with_http_info(search_string, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_by_syntax_string_document_search_get_with_http_info(search_string, **kwargs)  # noqa: E501
            return data

    def get_document_by_syntax_string_document_search_get_with_http_info(self, search_string, **kwargs):  # noqa: E501
        """search documents by zbMATH style user query  # noqa: E501

                 # Description                    The syntax search allows for free logical combinations of all         available search fields. While similar to the structured search,         this endpoint offers much more flexibility at the cost of obscure         search parameters.                    # Examples           - **Geometry**: Search for the term Geometry in any field. Queries are         case-independent.           - **Funct***: Wildcard queries are specified by * (e.g. functions,         functorial, etc.). Otherwise the search is exact.           - **\"Topological group\"**: Phrases (multi-words) should be set in         \"straight quotation marks\".           - **au: Bourbaki & ti: Algebra**: Search for author and title. The         and-operator & is default and can be omitted.           - **Chebyshev | Tschebyscheff**: The or-operator | allows to         search for Chebyshev or Tschebyscheff.           - **Quasi\\* map\\* py: 1989**: The resulting documents have         publication         year 1989.           - **so: Eur\\* J\\* Mat\\* Soc\\* cc: 14**: Search for publications in a         particular source with a Mathematics Subject Classification code (cc)         in 14.           - **\"Partial diff\\* eq\\*\" ! elliptic**: The not-operator ! eliminates         all results containing the word elliptic.           - **dt: b & au: Hilbert**: The document type is set to books;         alternatively: j for journal articles, a for book articles.           - **py: 2000-2015 cc: (94A | 11T)**: Number ranges are accepted.         Terms can be grouped within (parentheses).           - **la: chinese**: Find documents in a given language. ISO 639-1         (opens in new tab) language codes can also be used.          # Search fields  - **ab**: review text - **ac**: zbMATH code of a uniquely identified contributor of a document - **ai**: zbMATH code of any contributor of a document - **an**: zbMATH id of document. This includes all types of identifiers used on zbmath.org, i.e.: pre ID, Zbl ID, JFM ID, ERAM ID - **ar**: zbMATH code of an author reference - **au**: name of any contributor of a document - **bi**: zbMATH code of the biographic reference - **br**: name of the biographic reference - **ca**: zbMATH code of a uniquely identified author of a document - **cc**: title of msc code - **cca**: msc code (any level) - **ci**: cited documents - **db**: database name - **dt**: type of a document - **ec**: zbMATH code of a uniquely identified editor of a document - **ed**: name of editor - **ei**: zbMATH code of editor - **en**: external identifier or type - **ia**: zbMATH author code - **in**: zbMATH id of the corresponding issue - **la**: language - **li**: related url - **na**: number of authors of the document in question - **pt**: reviewing state - **pu**: publisher - **py**: year of publishing (range of year possible: XXXX-YYYY) - **ra**: zbMATH code of author in reference - **rc**: msc code of reference - **rf**: zbMATH id of reference - **rft**: reference text - **rj**: zbMATH id of serial - **rn**: zbMATH code of reviewer - **rv**: name of reviewer - **ry**: publishing year of reference - **se**: zbMATH id of serial - **si**: zbMATH id of related software - **so**: name of source - **st**: state of publication - **sw**: name of related software - **ti**: title - **ut**: keyword of the document            # Operators          - **a & b**: logical and          - **a | b**: logical or          - **!ab**: logical not          - **abc***: right wildcard          - **\"ab c\"**: phrase          - **(ab c)**: parentheses           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_by_syntax_string_document_search_get_with_http_info(search_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_string: (required)
        :param int page:
        :param int results_per_page:
        :return: ZbmathApiDataModelsDisplayDocumentsResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_string', 'page', 'results_per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_by_syntax_string_document_search_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_string' is set
        if ('search_string' not in params or
                params['search_string'] is None):
            raise ValueError("Missing the required parameter `search_string` when calling `get_document_by_syntax_string_document_search_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'search_string' in params:
            query_params.append(('search_string', params['search_string']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'results_per_page' in params:
            query_params.append(('results_per_page', params['results_per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/_search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZbmathApiDataModelsDisplayDocumentsResultSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document_by_zbmath_id_document_id_get(self, id, **kwargs):  # noqa: E501
        """get document data by zbMath ID  # noqa: E501

                 # Description                    # About this Endpoint            Use this endpoint if you have an zbMATH id of the document in         question. The result will contain only one dataset corresponding to         that id, if entered correctly.            # Example           - **6383667**           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_by_zbmath_id_document_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: ZbmathApiDataModelsDisplayDocumentsResultID
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_document_by_zbmath_id_document_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_by_zbmath_id_document_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_document_by_zbmath_id_document_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """get document data by zbMath ID  # noqa: E501

                 # Description                    # About this Endpoint            Use this endpoint if you have an zbMATH id of the document in         question. The result will contain only one dataset corresponding to         that id, if entered correctly.            # Example           - **6383667**           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_by_zbmath_id_document_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: ZbmathApiDataModelsDisplayDocumentsResultID
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_by_zbmath_id_document_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_document_by_zbmath_id_document_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZbmathApiDataModelsDisplayDocumentsResultID',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def intro_document_get(self, **kwargs):  # noqa: E501
        """introduction for user help regarding this endpoint  # noqa: E501

                # About this Endpoint         For searching in zbMATH you may employ the Structured Search,        which allows for convenient search of all relevant fields.         The syntax search on the other hand allows for free logical        combinations of all available search fields and is much more        flexible. In the following you will find a short explanation of        available search fields.         Use the Documents Search to find documents on specific topics,        by title or other characteristics. To find all publications by a        specific author or from a specific journal you should instead use the        respective search tab.                  - **/_search**: make use of the zbmath search syntax for complex        search. Examples on how to make use of the syntax can be found in        the endpoint itself.         - **/_structured_search**: a number of fields for a structured search         - **/{id}**: if a zbMATH id for the document in question is        available, you man enter it here, to return the meta data information        of just this one author.          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.intro_document_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.intro_document_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.intro_document_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def intro_document_get_with_http_info(self, **kwargs):  # noqa: E501
        """introduction for user help regarding this endpoint  # noqa: E501

                # About this Endpoint         For searching in zbMATH you may employ the Structured Search,        which allows for convenient search of all relevant fields.         The syntax search on the other hand allows for free logical        combinations of all available search fields and is much more        flexible. In the following you will find a short explanation of        available search fields.         Use the Documents Search to find documents on specific topics,        by title or other characteristics. To find all publications by a        specific author or from a specific journal you should instead use the        respective search tab.                  - **/_search**: make use of the zbmath search syntax for complex        search. Examples on how to make use of the syntax can be found in        the endpoint itself.         - **/_structured_search**: a number of fields for a structured search         - **/{id}**: if a zbMATH id for the document in question is        available, you man enter it here, to return the meta data information        of just this one author.          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.intro_document_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method intro_document_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
