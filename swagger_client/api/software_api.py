# coding: utf-8

"""
    REST API for zbMATH Open

    a REST api for zbMATH Open, currently with endpoints for authors, classifications, documents, serials and software  # noqa: E501

    OpenAPI spec version: v0.4.3rc0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SoftwareApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_software_by_field_software_structured_search_get(self, **kwargs):  # noqa: E501
        """search software meta data by descriptive field names  # noqa: E501

                 # Description                    For searching in zbMATH you may employ the Structured Search for         convenient combination of all search fields. While similar to the         1-line syntax search, this endpoint offers much more convenience and         transparency which fields are searched at the cost of search         flexibility.                    # Examples           - **field:** 'author', **term:** 'smith': Search for author named         **Smith**           - **field:** 'keyword', **term:** 'dynamic': Search for keyword         **dynamic** associated with the software           - **field:** 'programming_language', **term:** 'python': Search for         software based on the programming language **python**.          # Search fields  - **author**: name of author - **description**: description text - **keyword**: keyword - **msc**: related msc code - **name**: name of software - **programming_language**: programming language  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_by_field_software_structured_search_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page:
        :param int results_per_page:
        :param str author: author
        :param str description: description
        :param str keyword: keyword
        :param str msc: msc
        :param str name: name
        :param str programming_language: programming_language
        :return: ZbmathApiDataModelsDisplaySoftwareResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_software_by_field_software_structured_search_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_software_by_field_software_structured_search_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_software_by_field_software_structured_search_get_with_http_info(self, **kwargs):  # noqa: E501
        """search software meta data by descriptive field names  # noqa: E501

                 # Description                    For searching in zbMATH you may employ the Structured Search for         convenient combination of all search fields. While similar to the         1-line syntax search, this endpoint offers much more convenience and         transparency which fields are searched at the cost of search         flexibility.                    # Examples           - **field:** 'author', **term:** 'smith': Search for author named         **Smith**           - **field:** 'keyword', **term:** 'dynamic': Search for keyword         **dynamic** associated with the software           - **field:** 'programming_language', **term:** 'python': Search for         software based on the programming language **python**.          # Search fields  - **author**: name of author - **description**: description text - **keyword**: keyword - **msc**: related msc code - **name**: name of software - **programming_language**: programming language  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_by_field_software_structured_search_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page:
        :param int results_per_page:
        :param str author: author
        :param str description: description
        :param str keyword: keyword
        :param str msc: msc
        :param str name: name
        :param str programming_language: programming_language
        :return: ZbmathApiDataModelsDisplaySoftwareResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'results_per_page', 'author', 'description', 'keyword', 'msc', 'name', 'programming_language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_software_by_field_software_structured_search_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'results_per_page' in params:
            query_params.append(('results_per_page', params['results_per_page']))  # noqa: E501
        if 'author' in params:
            query_params.append(('author', params['author']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501
        if 'msc' in params:
            query_params.append(('msc', params['msc']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'programming_language' in params:
            query_params.append(('programming_language', params['programming_language']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/software/_structured_search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZbmathApiDataModelsDisplaySoftwareResultSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_software_by_id_software_id_get(self, id, **kwargs):  # noqa: E501
        """get software data by software id  # noqa: E501

                 # Description                    # About this Endpoint            Use this endpoint if you have the exact zbMATH id of the software in         question. The result will contain only one dataset corresponding to         that id, if entered correctly.            # Example           - **12**           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_by_id_software_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: ZbmathApiDataModelsDisplaySoftwareResultID
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_software_by_id_software_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_software_by_id_software_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_software_by_id_software_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """get software data by software id  # noqa: E501

                 # Description                    # About this Endpoint            Use this endpoint if you have the exact zbMATH id of the software in         question. The result will contain only one dataset corresponding to         that id, if entered correctly.            # Example           - **12**           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_by_id_software_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: ZbmathApiDataModelsDisplaySoftwareResultID
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_software_by_id_software_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_software_by_id_software_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/software/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZbmathApiDataModelsDisplaySoftwareResultID',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_software_by_syntax_string_software_search_get(self, search_string, **kwargs):  # noqa: E501
        """search software meta data by zbMATH style user query  # noqa: E501

                 # Description                    The syntax search allows for free logical combinations of all         available search fields. While similar to the structured search,         this endpoint offers much more flexibility at the cost of obscure         search parameters.                    # Examples           - **sw:Sage***: Search for a specific software package.           - **ab:geometry & ut:ORMS**: Search for software packages with the         word \"geometry\" in the description, and which have the keyword ORMS (         Oberwolfach Registry of Mathematical Software). The operator \"&\" is the         default and may be omitted.           - **cc:13 | 14**: Search for software packages which are cited by         articles belonging to the MSC sections 13 and 14.           - **GAP au:Eick**: Search for a term in the \"any\" index (which also         includes dependencies) and by software author.           - **pl:Java & ab:R**: Search for software package programmed in         Java whose description text contains \"R\"          # Search fields  - **ab**: description text - **au**: name of author - **cc**: related msc code - **pl**: programming language - **sw**: name of software - **ut**: keyword            # Operators          - **a & b**: logical and          - **a | b**: logical or          - **!ab**: logical not          - **abc***: right wildcard          - **\"ab c\"**: phrase          - **(ab c)**: parentheses           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_by_syntax_string_software_search_get(search_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_string: (required)
        :param int page:
        :param int results_per_page:
        :return: ZbmathApiDataModelsDisplaySoftwareResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_software_by_syntax_string_software_search_get_with_http_info(search_string, **kwargs)  # noqa: E501
        else:
            (data) = self.get_software_by_syntax_string_software_search_get_with_http_info(search_string, **kwargs)  # noqa: E501
            return data

    def get_software_by_syntax_string_software_search_get_with_http_info(self, search_string, **kwargs):  # noqa: E501
        """search software meta data by zbMATH style user query  # noqa: E501

                 # Description                    The syntax search allows for free logical combinations of all         available search fields. While similar to the structured search,         this endpoint offers much more flexibility at the cost of obscure         search parameters.                    # Examples           - **sw:Sage***: Search for a specific software package.           - **ab:geometry & ut:ORMS**: Search for software packages with the         word \"geometry\" in the description, and which have the keyword ORMS (         Oberwolfach Registry of Mathematical Software). The operator \"&\" is the         default and may be omitted.           - **cc:13 | 14**: Search for software packages which are cited by         articles belonging to the MSC sections 13 and 14.           - **GAP au:Eick**: Search for a term in the \"any\" index (which also         includes dependencies) and by software author.           - **pl:Java & ab:R**: Search for software package programmed in         Java whose description text contains \"R\"          # Search fields  - **ab**: description text - **au**: name of author - **cc**: related msc code - **pl**: programming language - **sw**: name of software - **ut**: keyword            # Operators          - **a & b**: logical and          - **a | b**: logical or          - **!ab**: logical not          - **abc***: right wildcard          - **\"ab c\"**: phrase          - **(ab c)**: parentheses           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_by_syntax_string_software_search_get_with_http_info(search_string, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_string: (required)
        :param int page:
        :param int results_per_page:
        :return: ZbmathApiDataModelsDisplaySoftwareResultSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_string', 'page', 'results_per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_software_by_syntax_string_software_search_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_string' is set
        if ('search_string' not in params or
                params['search_string'] is None):
            raise ValueError("Missing the required parameter `search_string` when calling `get_software_by_syntax_string_software_search_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'search_string' in params:
            query_params.append(('search_string', params['search_string']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'results_per_page' in params:
            query_params.append(('results_per_page', params['results_per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/software/_search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZbmathApiDataModelsDisplaySoftwareResultSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def intro_software_get(self, **kwargs):  # noqa: E501
        """introduction for user help regarding this endpoint software  # noqa: E501

                # About this Endpoint         For searching in zbMATH you may employ the Structured Search,        which allows for convenient search of all relevant fields.         The syntax search on the other hand allows for free logical        combinations of all available search fields and is much more        flexible. In the following you will find a short explanation of        available search fields.         Use the Software Search to find information on specific software        and where it is used.                  - **/_search**: make use of the zbMATH search syntax for complex        search. Examples on how to make use of the syntax can be found in        the endpoint itself.         - **/_structured_search**: a number of fields for a structured search         - **/{id}**: if a zbMATH id for the software in question is        available, you man enter it here, to return the meta data information        of just this one software entry.          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.intro_software_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.intro_software_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.intro_software_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def intro_software_get_with_http_info(self, **kwargs):  # noqa: E501
        """introduction for user help regarding this endpoint software  # noqa: E501

                # About this Endpoint         For searching in zbMATH you may employ the Structured Search,        which allows for convenient search of all relevant fields.         The syntax search on the other hand allows for free logical        combinations of all available search fields and is much more        flexible. In the following you will find a short explanation of        available search fields.         Use the Software Search to find information on specific software        and where it is used.                  - **/_search**: make use of the zbMATH search syntax for complex        search. Examples on how to make use of the syntax can be found in        the endpoint itself.         - **/_structured_search**: a number of fields for a structured search         - **/{id}**: if a zbMATH id for the software in question is        available, you man enter it here, to return the meta data information        of just this one software entry.          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.intro_software_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method intro_software_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/software/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
